<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Modelos SE - Controles (pan sync + carga)</title>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      background: black;
      color: white;
      font-family: sans-serif;
    }
    #controls {
      width: 250px;
      padding: 15px;
      background: rgba(0,0,0,0.8);
      overflow-y: auto;
    }
    #viewer { flex: 1; position: relative; }
    .mv {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
    }
    #viewerCasa, #viewerObj3 { pointer-events: none; } /* dejan pasar la interacción al principal */
    input[type="color"], input[type="range"], input[type="file"] { width:100%; margin:6px 0 12px; }
    h4 { margin:8px 0 4px; border-bottom:1px solid #555; }
  </style>
</head>
<body>
  <div id="controls">
    <h3>Controles</h3>

    <label>📂 Archivo 1 (SE Rojo):
      <input type="file" id="fileSE" accept=".glb,.gltf">
    </label>
    <label>📂 Archivo 2 (Casa Verde):
      <input type="file" id="fileCasa" accept=".glb,.gltf">
    </label>
    <label>📂 Archivo 3 (Obj3 Azul):
      <input type="file" id="fileObj3" accept=".glb,.gltf">
    </label>

    <label>🎨 Fondo:
      <input type="color" id="bgColor" value="#000000">
    </label>

    <h4>🔴 SE (rojo)</h4>
    <label>Color:
      <input type="color" id="colorSE" value="#ff0000">
    </label>
    <label>Opacidad:
      <input type="range" id="opacitySE" min="0" max="1" step="0.01" value="1">
    </label>

    <h4>🟢 Casa (verde)</h4>
    <label>Color:
      <input type="color" id="colorCasa" value="#00ff00">
    </label>
    <label>Opacidad:
      <input type="range" id="opacityCasa" min="0" max="1" step="0.01" value="1">
    </label>

    <h4>🔵 Obj3 (azul)</h4>
    <label>Color:
      <input type="color" id="colorObj3" value="#0000ff">
    </label>
    <label>Opacidad:
      <input type="range" id="opacityObj3" min="0" max="1" step="0.01" value="1">
    </label>

    <h4>🔍 Zoom Global</h4>
    <input type="range" id="zoomControl" min="5" max="200" step="1" value="50">
  </div>

  <div id="viewer">
    <model-viewer id="viewerSE" class="mv"
      alt="SE"
      camera-controls disable-tap
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>

    <model-viewer id="viewerCasa" class="mv"
      alt="Casa"
      camera-controls="false" disable-tap
      interaction-prompt="none"
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>

    <model-viewer id="viewerObj3" class="mv"
      alt="Obj3"
      camera-controls="false" disable-tap
      interaction-prompt="none"
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>
  </div>

  <script>
    const viewers = [
      document.getElementById('viewerSE'),
      document.getElementById('viewerCasa'),
      document.getElementById('viewerObj3')
    ];

    // --- carga de archivos ---
    function handleFileInput(input, viewer) {
      input.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
          viewer.src = URL.createObjectURL(file);
        }
      });
    }
    handleFileInput(document.getElementById('fileSE'), viewers[0]);
    handleFileInput(document.getElementById('fileCasa'), viewers[1]);
    handleFileInput(document.getElementById('fileObj3'), viewers[2]);

    // --- parse helpers ---
    function parseOrbit(orbit) {
      if (!orbit) return { theta: 0, phi: 0, radius: 50 };
      if (typeof orbit === 'string') {
        const tokens = orbit.trim().split(/\s+/);
        let theta=0, phi=0, radius=50;
        if (tokens[0]) {
          const t=tokens[0];
          theta = /deg$/.test(t) ? parseFloat(t)*Math.PI/180 :
                  /rad$/.test(t) ? parseFloat(t) : parseFloat(t);
        }
        if (tokens[1]) {
          const t=tokens[1];
          phi = /deg$/.test(t) ? parseFloat(t)*Math.PI/180 :
                /rad$/.test(t) ? parseFloat(t) : parseFloat(t);
        }
        if (tokens[2]) {
          const t=tokens[2];
          radius = /m$/.test(t)? parseFloat(t) : parseFloat(t);
        }
        return {theta, phi, radius};
      }
      return {theta: Number(orbit.theta||0), phi: Number(orbit.phi||0), radius: Number(orbit.radius||50)};
    }
    function orbitToString(o){ return `${o.theta}rad ${o.phi}rad ${o.radius}m`; }
    function parseTarget(t){ 
      if(!t) return {x:0,y:0,z:0};
      if(typeof t==='string'){ const nums=t.match(/-?[\d.]+/g)||[0,0,0]; return {x:+nums[0],y:+nums[1]||0,z:+nums[2]||0}; }
      return {x:+t.x||0,y:+t.y||0,z:+t.z||0};
    }
    function targetToString(t){ return `${t.x}m ${t.y}m ${t.z}m`; }

    // --- sincronización followers ---
    let f1Orbit={theta:0,phi:0,radius:50}, f2Orbit={theta:0,phi:0,radius:50};
    let f1Fov=45,f2Fov=45;
    let f1Target={x:0,y:0,z:0}, f2Target={x:0,y:0,z:0};
    const alpha1=0.22, alpha2=0.12;

    viewers[0].addEventListener('load',()=>{
      const o=parseOrbit(viewers[0].getCameraOrbit());
      f1Orbit={...o}; f2Orbit={...o};
      f1Fov=f2Fov=parseFloat(viewers[0].getFieldOfView())||45;
      const t=parseTarget(viewers[0].getCameraTarget());
      f1Target={...t}; f2Target={...t};
      requestAnimationFrame(syncLoop);
    });

    function syncLoop(){
      try{
        const o=parseOrbit(viewers[0].getCameraOrbit());
        const fov=parseFloat(viewers[0].getFieldOfView())||45;
        const t=parseTarget(viewers[0].getCameraTarget());
        // seguidor 1
        f1Orbit.theta+=(o.theta-f1Orbit.theta)*alpha1;
        f1Orbit.phi+=(o.phi-f1Orbit.phi)*alpha1;
        f1Orbit.radius+=(o.radius-f1Orbit.radius)*alpha1;
        f1Fov+=(fov-f1Fov)*alpha1;
        f1Target.x+=(t.x-f1Target.x)*alpha1;
        f1Target.y+=(t.y-f1Target.y)*alpha1;
        f1Target.z+=(t.z-f1Target.z)*alpha1;
        viewers[1].cameraOrbit=orbitToString(f1Orbit);
        viewers[1].fieldOfView=`${f1Fov}deg`;
        viewers[1].cameraTarget=targetToString(f1Target);
        // seguidor 2
        f2Orbit.theta+=(o.theta-f2Orbit.theta)*alpha2;
        f2Orbit.phi+=(o.phi-f2Orbit.phi)*alpha2;
        f2Orbit.radius+=(o.radius-f2Orbit.radius)*alpha2;
        f2Fov+=(fov-f2Fov)*alpha2;
        f2Target.x+=(t.x-f2Target.x)*alpha2;
        f2Target.y+=(t.y-f2Target.y)*alpha2;
        f2Target.z+=(t.z-f2Target.z)*alpha2;
        viewers[2].cameraOrbit=orbitToString(f2Orbit);
        viewers[2].fieldOfView=`${f2Fov}deg`;
        viewers[2].cameraTarget=targetToString(f2Target);
      }catch(e){}
      requestAnimationFrame(syncLoop);
    }

    // --- fondo ---
    document.getElementById('bgColor').addEventListener('input', e=>{
      viewers.forEach(v=>v.style.backgroundColor=e.target.value);
    });

    // --- materiales ---
    function applyMaterialAll(viewer,hex){
      if(!viewer.model||!viewer.model.materials)return;
      const r=parseInt(hex.slice(1,3),16)/255;
      const g=parseInt(hex.slice(3,5),16)/255;
      const b=parseInt(hex.slice(5,7),16)/255;
      viewer.model.materials.forEach(m=>{
        if(m?.pbrMetallicRoughness?.setBaseColorFactor){
          const prevA=m.pbrMetallicRoughness.baseColorFactor?.[3]??1;
          m.pbrMetallicRoughness.setBaseColorFactor([r,g,b,prevA]);
        }
      });
    }
    function bindControls(id,viewer){
      const c=document.getElementById(`color${id}`);
      const o=document.getElementById(`opacity${id}`);
      viewer.addEventListener('load',()=>{ applyMaterialAll(viewer,c.value); viewer.style.opacity=o.value; });
      c.addEventListener('input',()=>applyMaterialAll(viewer,c.value));
      o.addEventListener('input',()=>viewer.style.opacity=o.value);
    }
    bindControls("SE",viewers[0]);
    bindControls("Casa",viewers[1]);
    bindControls("Obj3",viewers[2]);

    // --- zoom global ---
    document.getElementById('zoomControl').addEventListener('input', e=>{
      const z=parseFloat(e.target.value);
      viewers.forEach(v=>{
        const o=parseOrbit(v.getCameraOrbit());
        o.radius=z; v.cameraOrbit=orbitToString(o);
      });
    });
  </script>
</body>
</html>

