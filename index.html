<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" /> 
  <title>Modelos SE - Controles (pan sync)</title>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      background: black;
      color: white;
      font-family: sans-serif;
    }
    #controls {
      width: 250px;
      padding: 15px;
      background: rgba(0,0,0,0.8);
      overflow-y: auto;
    }
    #viewer { flex: 1; position: relative; }
    .mv {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
    }
    #viewerCasa, #viewerObj3 { pointer-events: none; } /* dejan pasar la interacci√≥n al principal */
    input[type="color"], input[type="range"] { width:100%; margin:6px 0 12px; }
    h4 { margin:8px 0 4px; border-bottom:1px solid #555; }
  </style>
</head>
<body>
  <div id="controls">
    <h3>Controles</h3>

    <label>üé® Fondo:
      <input type="color" id="bgColor" value="#000000">
    </label>

    <h4>üî¥ Obj1 (rojo)</h4>
    <label>Color:
      <input type="color" id="colorSE" value="#ff0000">
    </label>
    <label>Opacidad:
      <input type="range" id="opacitySE" min="0" max="1" step="0.01" value="0.5"> <!-- Cambi√© el valor a 0.5 -->
    </label>

    <h4>üü¢ Obj2 (verde)</h4>
    <label>Color:
      <input type="color" id="colorCasa" value="#00ff00">
    </label>
    <label>Opacidad:
      <input type="range" id="opacityCasa" min="0" max="1" step="0.01" value="0.5"> <!-- Cambi√© el valor a 0.5 -->
    </label>

    <h4>üîµ Obj3 (azul)</h4>
    <label>Color:
      <input type="color" id="colorObj3" value="#0000ff">
    </label>
    <label>Opacidad:
      <input type="range" id="opacityObj3" min="0" max="1" step="0.01" value="0.5"> <!-- Cambi√© el valor a 0.5 -->
    </label>

    <h4>üîç Zoom Global</h4>
    <input type="range" id="zoomControl" min="5" max="200" step="1" value="50">

    <p style="font-size:0.8em;color:#aaa;">
      Coloca <b>SEBase.glb</b>, <b>SEEquipo.glb</b> y <b>SEEstructura.glb</b> en la misma carpeta.
    </p>
  </div>

  <div id="viewer">
    <model-viewer id="viewerSE" class="mv"
      src="SEBase.glb" alt="SE"
      camera-controls disable-tap
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>

    <model-viewer id="viewerCasa" class="mv"
      src="SEEquipo.glb" alt="Casa"
      camera-controls="false" disable-tap
      interaction-prompt="none"
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>

    <model-viewer id="viewerObj3" class="mv"
      src="SEEstructura.glb" alt="Obj3"
      camera-controls="false" disable-tap
      interaction-prompt="none"
      camera-orbit="0deg 75deg 50m"
      camera-target="0m 0m 0m"
      exposure="1" shadow-intensity="1"></model-viewer>
  </div>

  <script>
    const viewers = [
      document.getElementById('viewerSE'),
      document.getElementById('viewerCasa'),
      document.getElementById('viewerObj3')
    ];

    // --- util: parsear orbit string u objeto ---
    function parseOrbit(orbit) {
      if (!orbit) return { theta: 0, phi: 0, radius: 50 };
      if (typeof orbit === 'string') {
        const tokens = orbit.trim().split(/\s+/);
        let theta = 0, phi = 0, radius = 50;
        if (tokens[0]) {
          const t = tokens[0];
          theta = /deg$/.test(t) ? parseFloat(t) * Math.PI/180
                : /rad$/.test(t) ? parseFloat(t)
                : parseFloat(t);
        }
        if (tokens[1]) {
          const t = tokens[1];
          phi = /deg$/.test(t) ? parseFloat(t) * Math.PI/180
              : /rad$/.test(t) ? parseFloat(t)
              : parseFloat(t);
        }
        if (tokens[2]) {
          const t = tokens[2];
          radius = /m$/.test(t) ? parseFloat(t) : parseFloat(t);
        }
        return { theta: theta, phi: phi, radius: radius };
      }
      if (typeof orbit === 'object') {
        return {
          theta: Number(orbit.theta ?? orbit[0] ?? 0),
          phi:   Number(orbit.phi   ?? orbit[1] ?? 0),
          radius:Number(orbit.radius?? orbit[2] ?? 50)
        };
      }
      return { theta: 0, phi: 0, radius: 50 };
    }

    function orbitToString(o) {
      return `${o.theta}rad ${o.phi}rad ${o.radius}m`;
    }

    function parseTarget(target) {
      if (!target) return { x: 0, y: 0, z: 0 };
      if (typeof target === 'string') {
        const nums = target.match(/-?[\d.]+/g) || [0,0,0];
        return { x: parseFloat(nums[0]), y: parseFloat(nums[1]||0), z: parseFloat(nums[2]||0) };
      }
      if (typeof target === 'object') {
        return {
          x: Number(target.x ?? target[0] ?? 0),
          y: Number(target.y ?? target[1] ?? 0),
          z: Number(target.z ?? target[2] ?? 0)
        };
      }
      return { x: 0, y: 0, z: 0 };
    }

    function targetToString(t) {
      return `${t.x}m ${t.y}m ${t.z}m`;
    }

    let follower1Orbit = { theta:0, phi:0, radius:50 };
    let follower2Orbit = { theta:0, phi:0, radius:50 };
    let follower1Fov = 45, follower2Fov = 45;
    let follower1Target = { x:0, y:0, z:0 };
    let follower2Target = { x:0, y:0, z:0 };

    viewers[0].addEventListener('load', () => {
      const leaderOrbit = parseOrbit(viewers[0].getCameraOrbit());
      follower1Orbit = {...leaderOrbit};
      follower2Orbit = {...leaderOrbit};
      follower1Fov = parseFloat(viewers[0].getFieldOfView()) || follower1Fov;
      follower2Fov = parseFloat(viewers[0].getFieldOfView()) || follower2Fov;

      const leaderTarget = parseTarget(viewers[0].getCameraTarget());
      follower1Target = {...leaderTarget};
      follower2Target = {...leaderTarget};

      requestAnimationFrame(animateFollowers);
    });

    const alpha1 = 0.22;
    const alpha2 = 0.12;

    function animateFollowers() {
      try {
        const leaderOrbit = parseOrbit(viewers[0].getCameraOrbit());
        const leaderFov = parseFloat(viewers[0].getFieldOfView()) || follower1Fov;
        const leaderTarget = parseTarget(viewers[0].getCameraTarget());

        follower1Orbit.theta  += (leaderOrbit.theta  - follower1Orbit.theta)  * alpha1;
        follower1Orbit.phi    += (leaderOrbit.phi    - follower1Orbit.phi)    * alpha1;
        follower1Orbit.radius += (leaderOrbit.radius - follower1Orbit.radius) * alpha1;
        follower1Fov += (leaderFov - follower1Fov) * alpha1;

        follower2Orbit.theta  += (leaderOrbit.theta  - follower2Orbit.theta)  * alpha2;
        follower2Orbit.phi    += (leaderOrbit.phi    - follower2Orbit.phi)    * alpha2;
        follower2Orbit.radius += (leaderOrbit.radius - follower2Orbit.radius) * alpha2;
        follower2Fov += (leaderFov - follower2Fov) * alpha2;

        follower1Target.x += (leaderTarget.x - follower1Target.x) * alpha1;
        follower1Target.y += (leaderTarget.y - follower1Target.y) * alpha1;
        follower1Target.z += (leaderTarget.z - follower1Target.z) * alpha1;

        follower2Target.x += (leaderTarget.x - follower2Target.x) * alpha2;
        follower2Target.y += (leaderTarget.y - follower2Target.y) * alpha2;
        follower2Target.z += (leaderTarget.z - follower2Target.z) * alpha2;

        viewers[1].cameraOrbit = orbitToString(follower1Orbit);
        viewers[1].fieldOfView = `${follower1Fov}deg`;
        viewers[1].cameraTarget = targetToString(follower1Target);

        viewers[2].cameraOrbit = orbitToString(follower2Orbit);
        viewers[2].fieldOfView = `${follower2Fov}deg`;
        viewers[2].cameraTarget = targetToString(follower2Target);
      } catch (e) {
        console.warn('animateFollowers error', e);
      }
      requestAnimationFrame(animateFollowers);
    }

    document.getElementById('bgColor').addEventListener('input', e => {
      viewers.forEach(v => v.style.backgroundColor = e.target.value);
    });

    function applyMaterialAll(viewer, colorHex) {
      try {
        if (!viewer.model || !viewer.model.materials) return;
        const r = parseInt(colorHex.slice(1,3),16)/255;
        const g = parseInt(colorHex.slice(3,5),16)/255;
        const b = parseInt(colorHex.slice(5,7),16)/255;
        viewer.model.materials.forEach(mat=>{
          if (mat?.pbrMetallicRoughness?.setBaseColorFactor) {
            const prevA = mat.pbrMetallicRoughness.baseColorFactor?.[3] ?? 1;
            mat.pbrMetallicRoughness.setBaseColorFactor([r,g,b, prevA]);
          }
        });
      } catch(e) { console.warn('applyMaterialAll', e); }
    }

    function bindControls(idPrefix, viewer) {
      const colorEl = document.getElementById(`color${idPrefix}`);
      const opacityEl = document.getElementById(`opacity${idPrefix}`);

      viewer.addEventListener('load', () => {
        applyMaterialAll(viewer, colorEl.value);
        viewer.style.opacity = opacityEl.value;
      });

      colorEl.addEventListener('input', ()=>applyMaterialAll(viewer, colorEl.value));
      opacityEl.addEventListener('input', ()=>viewer.style.opacity = opacityEl.value);
    }

    bindControls("SE", viewers[0]);
    bindControls("Casa", viewers[1]);
    bindControls("Obj3", viewers[2]);

    document.getElementById('zoomControl').addEventListener('input', e=>{
      const zoom = parseFloat(e.target.value);
      viewers.forEach(v=>{
        const o = parseOrbit(v.getCameraOrbit());
        o.radius = zoom;
        v.cameraOrbit = orbitToString(o);
      });
    });
  </script>
</body>
</html>
